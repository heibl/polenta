## This code is part of the polenta package
## © F.-S. Krah (last update 2017-08-18)

#' GUIDetree-based AligNment ConficencE
#'
#' @description MSA reliability assessment GUIDANCE (Penn et al. 2010)
#'
#' @param sequences object of class \code{\link{DNAbin}} or
#'   \code{\link{AAbin}} containing unaligned sequences of DNA or amino acids.
#' @param ncore integer specifying the number of cores; default = 1 (serial), "auto" can be used for automated usage of all detected cores
#' @param bootstrap integer giving the number of alternative MSAs to be computed
#' @param msa.exec character string giving the path to the executable of the
#'   alignment program (e.g. "/usr/local/bin/mafft"); Must be on of: 'mafft', 'muscle', 'clustalo', 'clustalw2'
#' @param method further argument passed to mafft, default is \code{"auto"}
#'
#' @return object of class \code{polenta}:
#' @return msa original MSA as computed by \code{msa.program}
#' @return scores residue pair score
#'
#' @details Calculates column confidence (and other scors) by comparing
#'   alternative MSAs generated by alternative guide trees derived from
#'   bootstrap MSAs (Felsenstein 1985). The basic comparison between the BP MSAs
#'   and a reference MSA is if column residue pairs are identically aligned in
#'   all alternative MSAs compared with the base MSA (see \code{compareMSAs}).
#' @references Felsenstein J. 1985. Confidence limits on phylogenies: an
#'   approach using the bootstrap. Evolution 39:783–791
#' @references Penn et al. (2010). An alignment confidence score capturing
#'   robustness to guide tree uncertainty. Molecular Biology and Evolution
#'   27:1759--1767
#' @references G. Landan and D. Graur (2008). Local reliability measures from
#'   sets of co-optimal multiple sequencesuence alignments. 13:15--24
#'
#' @import ips
#' @import doSNOW
#' @import foreach
#' @import parallel
#' @import pbmcapply
#' @import plyr
#' @importFrom phangorn as.phyDat dist.ml
#'
#' @seealso \code{\link{msa_set_scoreR}}, \code{\link{guidance2}},
#'   \code{\link{HoT}}
#'
#' @examples
#' \dontrun{
#' # run GUIDANCE on example data using MAFFT
#' file <- system.file("extdata", "BB50009.fasta", package = "polenta")
#' aa_seq<- read.fas(file)
#' g_res <- guidance(sequences = aa_seq)
#' scores <- daughter_scores(g_res, score = c("gcsc", "rprsc"))
#' hist(scores$gcsc$score, xlab = "Column score", main = "GUIDANCE")
#' }
#'
#' @author Franz-Sebastian Krah
#' @export

guidance <- function(sequences,
  msa.exec = "/usr/local/bin/mafft",
  bootstrap = 100,
  ncore = 1,
  method = "auto",
  store_msas = FALSE){

  ##############################################
  ## SOME CHECKS
  ##############################################
  if (!inherits(sequences, c("DNAbin", "AAbin")))
    stop("sequences not of class DNAbin or AAbin (ape)")

  if (length(labels(sequences)) < 8)
    warning("GUIDANCE is not suitable for alignments of very few sequences.\n
      As a rule of thumb, use GUIDANCE2 or HoT for less than 8 sequences.")

  if(length(sequences) > 200)
    message("More than 200 sequences: consider using 'polenta'")

  ## look up MSA program specified
  msa.program <- str_extract(msa.exec, "mafft|muscle|clustalo|clustalw2")

  ## Check for MSA program
  if (missing(msa.exec)){
    os <- Sys.info()
    os <- os[grep("sysname", names(os))]
    if (msa.program == "mafft") {
      msa.exec <- switch(os, Linux = "mafft", Darwin = "mafft",
        Windows = "mafft.bat")
    }
    if (msa.program == "muscle") {
      msa.exec <- switch(os, Linux = "muscle", Darwin = "muscle",
        Windows = "muscle3.8.31_i86win32.exe")
    }
    if (msa.program == "clustalo") {
      msa.exec <- switch(os, Linux = "clustalo", Darwin = "clustalo",
        Windows = "clustalo.exe")
    }
    if (msa.program == "clustalw2") {
      msa.exec <- switch(os, Linux = "clustalw", Darwin = "clustalw2",
        Windows = "clustalw2.exe")
    }
  }
  out <- system(paste(msa.exec, "--v"), ignore.stdout = TRUE, ignore.stderr = TRUE)
  if (out == 127)
    stop("please provide msa.exec path or install MSA program in root \n
      i.e. in Unix: '/usr/local/bin/mafft'")

  ## generate some parameters if not specified
  ## -----------------------------------------
  ## number of cores
  if (ncore == "auto"){
    ncore <- detectCores(all.tests = FALSE, logical = TRUE)
  }

  ## if more than 200 species intermediate results are processed via files
  if(length(sequences)>200){
    int_file <- TRUE
  }else{
    int_file <- FALSE
  }

  ##############################################
  ## PART I
  ##############################################
  ## BASE and ALTERNATIVE MSAs
  ##############################################

  ## Generate BASE MSA
  #---------------------------------------------
  cat("Generating the base alignment \n")

  ## create loop input
  if(msa.program=="mafft")
  { mafft_method <- ", method = method" }else{ mafft_method <- "" }

  base.msa <- paste(msa.program, "(",
    "x = sequences, exec = msa.exec",
    mafft_method, ")", sep = "")

  ## Make alignment
  base.msa <- eval(parse(text = base.msa))

  ## Constructing BP guide-trees for the pertubated MSAs
  #--------------------------------------------------------
  cat("Generating NJ guide trees \n")
  ## Compute NJ guide trees

  pb <- txtProgressBar(max = bootstrap, style = 3)

  progress <- function(n) setTxtProgressBar(pb, n)
  opts <- list(progress = progress)

  cl <- makeCluster(ncore)
  registerDoSNOW(cl)

  nj.guide.trees <- foreach(i = 1:bootstrap,
    .options.snow = opts,
    .packages = "phangorn", .export = 'msaBP_nj_tree') %dopar% {
      msaBP_nj_tree(base.msa, outgroup = "auto")
    }
  stopCluster(cl)
  close(pb)

  ## Alignment of MSA BP times with new NJ guide trees
  ## -------------------------------------------------
  cat("Alignment of sequences using NJ guide trees \n")


  ## store intermediate results in the temporary files
  if(int_file){
    msa_out <- vector(length = bootstrap)
    for (i in seq_along(msa_out))
      msa_out[i] <- tempfile(pattern = "mafft",
        tmpdir = tempdir(), fileext = ".fas")
    unlink(msa_out[file.exists(msa_out)])
  }

  ## construct loop function
  ##########################
  if(msa.program=="mafft")
  { mafft_method <- paste(", method =", "'", method, "'", sep="") }else{ mafft_method <- "" }

  if(int_file)
  { intfile <- ", file = msa_out[i]" }else{ intfile <- "" }

  FUN <- function(i) {paste(msa.program, "(",
    "x = sequences, gt = nj.guide.trees[[", i,"]], exec = msa.exec",
    mafft_method, intfile, ")", sep = "")}

  ## loop
  bpb <- txtProgressBar(max = bootstrap, style = 3)
  progress <- function(n) setTxtProgressBar(pb, n)
  opts <- list(progress = progress)
  cl <- makeCluster(ncore)
  registerDoSNOW(cl)

  alt.msa <- foreach(i = 1:bootstrap, .packages = c('ips', 'ape'),
    .options.snow = opts,
    .export = c("sequences", "nj.guide.trees", "msa.exec"))  %dopar% {
      eval(parse(text = FUN(i)))
    }

  stopCluster(cl)
  close(pb)

  ## detele some unnecessary files
  mafft_created <- list.files(getwd(),
    full.names = TRUE)[grep("tree.mafft", list.files(getwd()))]
  if (length(mafft_created)){
    file.remove(mafft_created)
  }

  ##############################################
  ## PART II
  ##############################################
  ## Computation of GUIDANCE scores
  ##############################################
  cat("Calculating GUIDANCE scores \n")

  if(int_file){
    ## Create temporary dir for alternative MSAs
    dir.create(paste(tempdir(), "alt", sep = "/"))
    files_from <- list.files(tempdir(), full.names = TRUE)
    files_from <- files_from[grep("\\.fas", files_from)]
    files_to <- list.files(tempdir())
    files_to <- files_to[grep("\\.fas", files_to)]
    files_to <- paste(tempdir(), "alt", files_to, sep="/")

    ## Move files into new dir
    file.rename(files_from, files_to)

    rm(alt.msa)
    alt.msa <- paste(tempdir(), "alt", sep = "/")

  }

  ## Run msa_set_score
  # switch(score_method,
    # "Rcpp" = {
      ## Rcpp functions are called
      score <- msa_set_scoreR(ref = base.msa,
        alt = alt.msa)
      # }
    # "SA" = {
    #   ## msa_set_score from GUIDANCE package is called
    #   score <- msa_set_scoreSA(ref = base.msa,
    #     alt = alt.msa,
    #     bootstrap = bootstrap, exec = msa_set_score.exec)
    # }
  # )
  ### score comutation done


  ##  if wanted, store alternative MSAs into a zip file
  if (!missing(store_msas)){
    files <- list.files(paste(tempdir(), "alt", sep = "/"))
    files <- files[grep("HoT", files)]
    for (i in 1:(n.coopt*bootstrap)){
      file.rename(paste(tempdir(), files[i], sep = "/"),
        paste(tempdir(), paste0("altMSA", i, ".fas"), sep = "/"))}
    files <- list.files(tempdir(), full.names = TRUE)
    files <- files[grep("altMSA*", files)]
    zip(zipfile = alt.msas.file, files = files)

  # maybe use gzfile
  # currently zip creates many wired subfolders
  }

  ## Delete temporary files
  # this deletion approach has proven best to delete everything
  files <- list.files(tempdir(), full.names = TRUE)
  files <- files[-grep("rs-graphics", files)]
  unlink(files, force = TRUE, recursive = TRUE)

  ## Prepare and return output
  ## -------------------------
  # if(score_method=="SA"){
  #   score <- score$residue_pair_score
  # }
  if(inherits(sequences, "AAbin")){
    polentaAA(base.msa, score, "guidance")
  }else{
    polentaDNA(base.msa, score, "guidance")
  }
}
