## This code is part of the polenta package
## © F.-S. Krah (last update 2017-08-18)

#' GUIDetree-based AligNment ConficencE
#'
#' @description MSA reliability assessment GUIDANCE (Penn et al. 2010)
#'
#' @param sequences An object of class \code{\link{DNAbin}} or
#'   \code{\link{AAbin}} containing unaligned sequences of DNA or amino acids.
#' @param parallel logical, if TRUE, specify the number of cores
#' @param ncore number of cores (default is maxinum of local threads)
#' @param bootstrap An integer giving the number of perturbated MSAs.
#' @param msa.program A charcter string giving the name of the MSA program,
#'   currelty one of c("mafft", "muscle", "clustalo", "clustalw2"); MAFFT is
#'   default
#' @param exec A character string giving the path to the executable of the
#'   alignment program.
#' @param method further arguments passed to mafft, default is \code{"auto"}
#' @param nj.program specify if R functions or SEMPHY should be used for guide-tree estimation
#'
#' @details Calculates column confidence (and other scors) by comparing
#'   alternative MSAs generated by alternative guide trees derived from
#'   bootstrap MSAs (Felsenstein 1985). The basic comparison between the BP MSAs
#'   and a reference MSA is if column residue pairs are identically aligned in
#'   all alternative MSAs compared with the base MSA (see \code{compareMSAs}).
#' @references Felsenstein J. 1985. Confidence limits on phylogenies: an
#'   approach using the bootstrap. Evolution 39:783–791
#' @references Penn et al. (2010). An alignment confidence score capturing
#'   robustness to guide tree uncertainty. Molecular Biology and Evolution
#'   27:1759--1767
#' @references G. Landan and D. Graur (2008). Local reliability measures from
#'   sets of co-optimal multiple sequencesuence alignments. 13:15--24
#'
#' @import ips
#' @import doSNOW
#' @import foreach
#' @import parallel
#' @import pbmcapply
#' @import plyr
#' @importFrom phangorn as.phyDat dist.ml
#'
#' @seealso \code{\link{compareMSAs}}, \code{\link{guidance2}},
#'   \code{\link{HoT}}
#'
#' @examples
#' \dontrun{
#' # run GUIDANCE on example data using MAFFT
#' file <- system.file("extdata", "BB50009.fasta", package = "rpg")
#' aa_seq<- read.fas(file)
#' g_res <- guidance(sequences = aa_seq)
#' scores <- daughter_scores(g_r, score = c("gcsc", "rprsc"))
#' hist(scores$gcsc$score, xlab = "Column score", main = "GUIDANCE")
#' }
#'
#' @author Franz-Sebastian Krah
#' @export

guidance <- function(sequences,
  msa.program = "mafft", msa.exec = "/usr/local/bin/mafft",
  bootstrap = 100,
  parallel = FALSE, ncore ="auto",
  method = "auto",
  int_file = FALSE,
  alt.msas.file,
  nj.program = "R",
  score_method = "Rcpp",
  msa_set_score.exec){

  ##############################################
  ## SOME CHECKS
  ##############################################
  if (!inherits(sequences, c("DNAbin", "AAbin")))
    stop("sequences not of class DNAbin or AAbin (ape)")


  if (length(labels(sequences)) < 8)
    warning("GUIDANCE is not suitable for alignments of very few sequences.\n
      As a rule of thumb, use GUIDANCE2 or HoT for less than 8 sequences.")

  ## Check for MSA program
  if (missing(msa.exec)){
    os <- Sys.info()
    os <- os[grep("sysname", names(os))]
    if (msa.program == "mafft") {
      msa.exec <- switch(os, Linux = "mafft", Darwin = "mafft",
        Windows = "mafft.bat")
    }
    if (msa.program == "muscle") {
      msa.exec <- switch(os, Linux = "muscle", Darwin = "muscle",
        Windows = "muscle3.8.31_i86win32.exe")
    }
    if (msa.program == "clustalo") {
      msa.exec <- switch(os, Linux = "clustalo", Darwin = "clustalo",
        Windows = "clustalo.exe")
    }
    if (msa.program == "clustalw2") {
      msa.exec <- switch(os, Linux = "clustalw", Darwin = "clustalw2",
        Windows = "clustalw2.exe")
    }
  }
  out <- system(paste(msa.exec, "--v"), ignore.stdout = TRUE, ignore.stderr = TRUE)
  if (out == 127)
    stop("please provide msa.exec path or install MSA program in root \n
      i.e. in Unix: '/usr/local/bin/mafft'")

  ## generate some parameters if not specified
  ## -----------------------------------------
  ## number of cores
  if (parallel == TRUE & ncore == "auto"){
    ncore <- detectCores(all.tests = FALSE, logical = TRUE)
  }
  if(!parallel){ncore = 1}

  ##############################################
  ## PART I
  ##############################################
  ## BASE and ALTERNATIVE MSAs
  ##############################################

  ## Generate BASE MSA
  #---------------------------------------------
  cat("Generating the base alignment \n")

  ## create loop input
  if(msa.program=="mafft")
  { mafft_method <- ", method = method" }else{ mafft_method <- "" }

  base.msa <- paste(msa.program, "(",
    "x = sequences, exec = msa.exec",
    mafft_method, ")", sep = "")

  ## Make alignment
  base.msa <- eval(parse(text = base.msa))

  cat("... done \n")

  ## Constructing BP guide-trees for the pertubated MSAs
  #--------------------------------------------------------
  cat("Generating NJ guide trees \n")
  ## Compute NJ guide trees

  if (nj.program =="semphy"){
    #### SEMPHY  ###
    if(nrow(base.msa) > 150){
      if (type == "DNA")
        model <- "--nucjc"
      if (type == "AA")
        model <- "--aaJC"
    } else {
      if (tpye == "DNA")
        model <- "--hky"
      if (type == "AA")
        model <- "--jtt"
    }
    nj.guide.trees <- semphy(msa = base.msa,
      dist.table<- "-J",
      model <- model,
      arsv <- "-H",
      bootstrap = bootstrap,
      verbose = verbose)

    # lapply(nj.guide.trees, root, outgroup = )
    nj.guide.trees <- lapply(nj.guide.trees, compute.brlen)
  }

  pb <- txtProgressBar(max = bootstrap, style = 3)

  if (nj.program == "R"){

    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)

    nj.guide.trees <- foreach(i = 1:bootstrap,
      .options.snow = opts,
      .packages = "phangorn", .export = 'msaBP_nj_tree') %dopar% {
        msaBP_nj_tree(base.msa, outgroup = "auto")
      }
    stopCluster(cl)
  }
  close(pb)

  ## Alignment of MSA BP times with new NJ guide trees
  ## -------------------------------------------------
  cat("Alignment of sequences using NJ guide trees \n")


  ## store intermediate results in the temporary files
  if(int_file){
    msa_out <- vector(length = bootstrap)
    for (i in seq_along(msa_out))
      msa_out[i] <- tempfile(pattern = "mafft",
        tmpdir = tempdir(), fileext = ".fas")
    unlink(msa_out[file.exists(msa_out)])
  }

  ## construct loop function
  ##########################
  if(msa.program=="mafft")
  { mafft_method <- paste(", method =", "'", method, "'", sep="") }else{ mafft_method <- "" }

  if(int_file)
  { intfile <- ", file = msa_out[i]" }else{ intfile <- "" }

  FUN <- function(i) {paste(msa.program, "(",
    "x = sequences, gt = nj.guide.trees[[", i,"]], exec = msa.exec",
    mafft_method, intfile, ")", sep = "")}

  ## loop
  bpb <- txtProgressBar(max = bootstrap, style = 3)
  progress <- function(n) setTxtProgressBar(pb, n)
  opts <- list(progress = progress)
  cl <- makeCluster(ncore)
  registerDoSNOW(cl)

  alt.msa <- foreach(i = 1:bootstrap, .packages = c('ips', 'ape'),
    .options.snow = opts,
    .export = c("sequences", "nj.guide.trees", "msa.exec"))  %dopar% {
      eval(parse(text = FUN(i)))
    }

  stopCluster(cl)
  close(pb)

  ## detele some unnecessary files
  mafft_created <- list.files(getwd(),
    full.names = TRUE)[grep("tree.mafft", list.files(getwd()))]
  if (length(mafft_created)){
    file.remove(mafft_created)
  }

  ##############################################
  ## PART II
  ##############################################
  ## Computation of GUIDANCE scores
  ##############################################
  cat("Calculating GUIDANCE scores \n")

  # ## GUIDANCE Score
  #----------------------------------------------

  if(int_file){
    ## Create temporary dir for alternative MSAs
    dir.create(paste(tempdir(), "alt", sep = "/"))
    files_from <- list.files(tempdir(), full.names = TRUE)
    files_from <- files_from[grep("\\.fas", files_from)]
    files_to <- list.files(tempdir())
    files_to <- files_to[grep("\\.fas", files_to)]
    files_to <- paste(tempdir(), "alt", files_to, sep="/")

    ## Move files into new dir
    file.rename(files_from, files_to)

    rm(alt.msa)
    alt.msa <- paste(tempdir(), "alt", sep = "/")

  }

  ## Run msa_set_score

  switch(score_method,
    "Rcpp" = {
      ## Rcpp functions are called
      score <- msa_set_scoreR(ref = base.msa,
        alt = alt.msa, bootstrap = bootstrap)
      },
    "SA" = {
      ## msa_set_score from GUIDANCE package is called
      score <- msa_set_scoreSA(ref = base.msa,
        alt = alt.msa,
        bootstrap = bootstrap, exec = msa_set_score.exec)
    }
  )

  ##  if wanted, store alternative MSAs into a zip file
  # if (!missing(alt.msas.file)){
  #   files <- list.files(paste(tempdir(), "alt", sep = "/"))
  #   files <- files[grep("HoT", files)]
  #   for (i in 1:(n.coopt*bootstrap)){
  #     file.rename(paste(tempdir(), files[i], sep = "/"),
  #       paste(tempdir(), paste0("altMSA", i, ".fas"), sep = "/"))}
  #   files <- list.files(tempdir(), full.names = TRUE)
  #   files <- files[grep("altMSA*", files)]
  #   zip(zipfile = alt.msas.file, files = files)

  # maybe better to use gzfile
  ## currently zip creates many wired subfolders
  # }

  ## Delete temporary files
  # this deletion approach has proven best to delete everything
  files <- list.files(tempdir(), full.names = TRUE)
  files <- files[-grep("rs-graphics", files)]
  unlink(files, force = TRUE, recursive = TRUE)

  ## Reduce MSA according to cutoffs, it wanted
  ## WILL BE TRASFERRED TO METHOD FOR polentaDNA class
  #---------------------------------------------------
  # msa <- guidance.msa <- base.msa
  # msa <- as.character(msa)
  # ## masking residues below cutoff
  # if (mask.cutoff > 0){
  #   txt <- as.vector(as.character(base.msa))
  #   # mat <- data.frame(rpr.sc, txt)
  #   mat <- data.frame(scores$residue_pair_residue_score, txt)
  #   rown <- max(mat$residue)
  #   coln <- max(mat$col)
  #   res_mat <- matrix(mat$score, nrow = rown, ncol = coln)
  #
  #   if (mask.cutoff == "auto"){ mask.cutoff <- 0.50 }
  #
  #   if (inherits(sequences, "DNAbin")){
  #     msa[res_mat<mask.cutoff & !is.na(res_mat)] <- "N"
  #     msa <- as.DNAbin(msa)
  #   }
  #   if (inherits(sequences, "AAbin")) {
  #     msa[res_mat<mask.cutoff & !is.na(res_mat)] <- "X"
  #     rownames(msa) <- labels(sequences)
  #     class(msa) <- "AAbin"
  #   }
  #   guidance.msa <- msa
  # }
  # ## remove unreliable columns
  # if (col.cutoff > 0){
  #   if (mask.cutoff) {
  #     msa <- guidance.msa
  #   } else {
  #     msa <- base.msa
  #     }
  #   if (col.cutoff == "auto"){ col.cutoff <- 0.97 }
  #   # remove_cols <- g.cs$res_pair_col_score < col.cutoff
  #   remove_cols <- scores$column_score$CS < col.cutoff
  #   guidance.msa <- msa[, !remove_cols]
  # }
  # ## remove unreliable sequences
  # if (seq.cutoff > 0){
  #   if (mask.cutoff) { msa <- guidance.msa
  #   } else { msa <- base.msa }
  #   if (seq.cutoff =="auto"){seq.cutoff <- 0.5}
  #   # remove_sequences <- rps.sc$res_pair_seq_score < seq.cutoff
  #   remove_sequences <- scores$residual_pair_sequence_score$score < seq.cutoff
  #   guidance.msa <- msa[!remove_sequences,]
  # }
  #
  # ## Generate output
  # res <- list(scores = scores,
  #   GUIDANCE_msa = guidance.msa,
  #   base_msa = base.msa)

  ## Prepare and return output
  ## -------------------------
  if(score_method=="SA"){
    score <- score$residue_pair_score
  }
  if(inherits(sequences, "AAbin")){
    polentaAA(base.msa, score, "guidance")
  }else{
    polentaDNA(base.msa, score, "guidance")
  }
}
