## This code is part of the polenta package
## © F.-S. Krah (last update 2017-08-18)

#' MSA reliability assessment GUIDANCE2 (Sela et al. 2015)
#'
#' @param sequences object of class \code{\link{DNAbin}} or
#'   \code{\link{AAbin}} containing unaligned sequences of DNA or amino acids.
#' @param ncore integer specifying the number of cores; default = 1 (serial), "auto" can be used for automated usage of all detected cores
#' @param bootstrap integer giving the number of alternative MSAs to be computed
#' @param msa.exec character string giving the path to the executable of the
#'   alignment program (e.g. "/usr/local/bin/mafft"); Must be on of: 'mafft', 'muscle', 'clustalo', 'clustalw2'
#' @param method further argument passed to mafft, default is \code{"auto"}
#'
#' @return object of class \code{polenta}:
#' @return msa original MSA as computed by \code{msa.program}
#' @return scores residue pair score
#'
#' @details Calculates column confidence (and other scors) by comparing alternative MSAs generated by the GUIDANCE with varying gap opening panelty and the HoT methodology. First 100 alternative MSAs (with BP guide trees) with varying gap opening panelty are produced, then for each n (default = 4) co-optimal alignments are produced using HoT. The basic comparison between the BP MSAs and a reference MSA is if column residue pairs are identically aligned in all alternative MSAs compared with the base MSA (see \code{compareMSAs}).
#'
#' @references Felsenstein J. 1985. Confidence limits on phylogenies: an
#'   approach using the bootstrap. Evolution 39:783–791
#' @references Penn et al. (2010). An alignment confidence score capturing
#'   robustness to guide tree uncertainty. Molecular Biology and Evolution
#'   27:1759--1767
#' @references Sela et al. (2015). GUIDANCE2: accurate detection of unreliable alignment regions accounting for the uncertainty of multiple parameters. Nucleic acids research 43:W7--W14
#' @references G. Landan and D. Graur (2008). Local reliability measures from sets of co-optimal multiple sequencesuence alignments. Pacific Symposium on Biocomputin. 13:15--24
#'
#' @importFrom ips mafft
#' @import doSNOW
#' @import foreach
#' @import parallel
#' @import pbmcapply
#' @import plyr
#' @importFrom phangorn as.phyDat dist.ml
#'
#' @seealso \code{\link{compareMSAs}}, \code{\link{guidance}}, \code{\link{HoT}}
#'
#' @author Franz-Sebastian Krah
#' @export



guidance2 <- function(sequences,
                      msa.exec = "/usr/local/bin/mafft",
                      bootstrap = 100,
                      n.part = "auto",
                      ncore = 1,
                      method = "auto",
                      store_msas = FALSE,
                      n.coopt = "auto"){

  ##############################################
  ## SOME CHECKS
  ##############################################
  if (!inherits(sequences, c("DNAbin", "AAbin")))
    stop("sequences not of class DNAbin or AAbin (ape)")

  if(length(sequences) > 200)
    message("More than 200 sequences: consider using 'polenta'")


  ## look up MSA program specified
  msa.program <- str_extract(msa.exec, "mafft|muscle|clustal\\w")

  ## Check for MSA program
  if (missing(msa.exec)){
    os <- Sys.info()[1]
    if (msa.program == "mafft") {
      msa.exec <- switch(os, Linux = "mafft", Darwin = "mafft",
        Windows = "mafft.bat")
    }
    if (msa.program == "muscle") {
      msa.exec <- switch(os, Linux = "muscle", Darwin = "muscle",
        Windows = "muscle3.8.31_i86win32.exe")
    }
    if (msa.program == "clustalw2") {
      msa.exec <- switch(os, Linux = "clustalw", Darwin = "clustalw2",
        Windows = "clustalw2.exe")
    }
  }
  out <- system(paste(msa.exec, "--v"), ignore.stdout = TRUE, ignore.stderr = TRUE)
  if (out == 127)
    stop("please provide exec path or install MSA program in root \n
      i.e. in Unix: '/usr/local/bin/mafft'")


  ## generate some parameters if not specified
  #---------------------------------------------
  ## number of cores
  if (ncore == "auto"){
    ncore <- detectCores(all.tests = FALSE, logical = TRUE)
  }

  ## specify number of sampled co-optimal MSAs from HoT
  if (n.coopt == "auto"){ n.coopt <- 4 }


  ## if more than 200 species intermediate results are processed via files
  if(length(sequences)>200){
    int_file <- TRUE
  }else{
    int_file <- FALSE
  }
  ##############################################
  ## PART I
  ##############################################
  ## BASE and PERTUBATED MSAs
  ##############################################

  ## Generate BASE alignment
  ###########################
  cat("Generating the base alignment")

  ## create loop input
  if(msa.program=="mafft")
  { mafft_method <- ", method = method" }else{ mafft_method <- "" }

  base.msa <- paste(msa.program, "(",
    "x = sequences, exec = msa.exec",
    mafft_method, ")", sep = "")

  ## Make alignment
  base.msa <- eval(parse(text = base.msa))



  ###
  cat("Generating NJ guide trees \n")
  ## Compute NJ guide trees

  pb <- txtProgressBar(max = bootstrap, style = 3)
  progress <- function(n) setTxtProgressBar(pb, n)
  opts <- list(progress = progress)

  cl <- makeCluster(ncore)
  registerDoSNOW(cl)

  nj.guide.trees <- foreach(i = 1:bootstrap,
    .options.snow = opts,
    .packages = "phangorn", .export = 'msaBP_nj_tree') %dopar% {
      msaBP_nj_tree(base.msa, outgroup = "auto")
    }
  stopCluster(cl)
  close(pb)


  ## Alignment of MSA BP times with new NJ guide trees
  ## -------------------------------------------------
  cat("Alignment of alternative MSAs using NJ guide trees (GUIDANCE)\n")

  ## Prepare TEMP files for all outputs (GUIDANCE + HoT)
  if(int_file){
    msa_out <- vector(length = (bootstrap + (bootstrap*n.coopt)))
    for (i in 1:bootstrap)
      msa_out[i] <- tempfile(pattern = "mafft", tmpdir = tempdir(), fileext = ".fas")
    for (i in 1:(bootstrap*n.coopt))
      msa_out[i+bootstrap] <- tempfile(pattern = "HoT", tmpdir = tempdir(), fileext = ".fas")
    unlink(msa_out[file.exists(msa_out)])
  }

  ## Align perturbated MSAs (GUIDANCE)
  pb <- txtProgressBar(max = bootstrap, style = 3)

  progress <- function(n) setTxtProgressBar(pb, n)
  opts <- list(progress = progress)
  cl <- makeCluster(ncore)
  registerDoSNOW(cl)

  if(int_file)
  { intfile <- ", file = msa_out[i]" }else{ intfile <- "" }

  switch(msa.program,

    mafft={
    FUN <- function(i) {
      paste("mafft(x = sequences, gt = nj.guide.trees[[", i, "]],
      exec = msa.exec, method = method,
      op = runif(1,0,5))", intfile, sep ="")
    }},
      muscle={
    FUN <- function(i) {
      paste("muscle2(x = sequences, gt = nj.guide.trees[[,", i, ", ]],
        exec = msa.exec, MoreArgs = paste('-gapopen ', format(runif(1, -400, -10), digits = 0)",
        intfile,")", sep ="")
    }},
  clustalw2={
    FUN <- function(i) {
      paste("clustalw2(x = sequences, gt = nj.guide.trees[[,", i, "]],
          exec = msa.exec, file = msa_out[i],
        MoreArgs = paste('-PAIRGAP=', format(runif(1, 1, 9), digits = 0), sep =')')",
        intfile, ")",sep ="")
    }})

  msa_out <- foreach(i = 1:bootstrap, .packages=c('ips', 'ape', 'polenta'),
    .export = c("sequences", "nj.guide.trees", "msa.exec", "method"),
    .options.snow = opts)  %dopar% {
      eval(parse(text = FUN(i)))
    }
  stopCluster(cl)
  close(pb)

  mafft_created <- list.files(getwd(),
    full.names = T)[grep("tree.mafft", list.files(getwd()))]
  if(length(mafft_created)>0){
    file.remove(mafft_created)
  }



  ##############################################
  ## PART III
  ##############################################
  ## Generate co-optimal alignments with HoT
  ##############################################
  cat(paste("Sampling", n.coopt, "co-optimal MSAs (HoT) for each alternative MSA \n",
    sep=" "))

  # predifined file allocation

  start <- seq(1,n.coopt*bootstrap,n.coopt)
  end <- seq(n.coopt,n.coopt*bootstrap,n.coopt)
  stend <- data.frame(start, end)
  stend <- stend + bootstrap

  ## run HoT

  progress <- function(n) setTxtProgressBar(pb, n)
  opts <- list(progress = progress)
  cl <- makeCluster(ncore)
  registerDoSNOW(cl)

  FUN <- function(i){
    paste("Hot_GUIDANCE2(msa = msa_out",
      ifelse(int_file, "[", "[["), i, ifelse(int_file, "]", "]]"),
      ", n.coopt = n.coopt,
      files = msa_out[stend[" ,i, ",1]:stend[" ,i, ",2]], int_file = ", int_file, ",
      raw_seq = sequences, msa.program = msa.program,
      method = method, msa.exec = msa.exec)")
  }

  alt.msa <- foreach(i = 1:bootstrap,.options.snow = opts,
    .packages = c('polenta', 'ips', 'adephylo', 'foreach', 'phangorn'),
    .export = c("n.coopt", "sequences", "msa.program",
      "method", "msa.exec", "msa_out")) %dopar% {
      eval(parse(text = FUN(i)))
    }
  stopCluster(cl)
  close(pb)


  #### unlist nested list
  if(!int_file){
    alt.msa <- foreach(i = 1:length(alt.msa), .combine = c) %do% {
      alt.msa[[1]]
    }
  }

  ##############################################
  ## PART IV
  ##############################################
  ## Computation of GUIDANCE 2 scores
  ##############################################
  cat("Calculating GUIDANCE2 scores \n")

  # ## GUIDANCE Score
  # ##############################################

  if(int_file){
    dir.create(paste(tempdir(), "alt", sep="/"))
    files_from <- list.files(tempdir(), full.names = TRUE)
    files_from <- files_from[grep("\\.fas", files_from)]
    files_to <- list.files(tempdir())
    files_to <- files_to[grep("\\.fas", files_to)]
    files_to <- paste(tempdir(), "alt", files_to, sep="/")

    file.rename(files_from, files_to)

    rm(alt.msa)
    alt.msa <- paste(tempdir(), "alt", sep = "/")
  }

  ## Run msa_set_score
  # switch(score_method,
  #   "Rcpp" = {
  #     ## Rcpp functions are called
      score <- msa_set_scoreR(ref = base.msa,
        alt = alt.msa)
  #   },
  #   "SA" = {
  #     ## msa_set_score from GUIDANCE package is called
  #     score <- msa_set_scoreSA(ref = base.msa,
  #       alt = alt.msa, bootstrap = bootstrap,
  #       exec = msa_set_score.exec)
  #   }
  # )


  ##  if wanted, store alternative MSAs into a zip file
  if(!missing(store_msas)){
    files <- list.files(tempdir())
    files <- files[grep("HoT", files)]
    for(i in 1:(n.coopt*bootstrap)){
      file.rename(paste(tempdir(), files[i], sep="/"),
        paste(tempdir(), paste("altMSA", i, ".fas",sep=""), sep="/"))}
    files <- list.files(tempdir(), full.names = TRUE)
    files <- files[grep("altMSA*", files)]
    zip(zipfile = alt.msas.file, files = files)

    # maybe better to use gzfile
    ## currently zip creates many wired subfolders
  }

  ## delete temporary files in temporary directory
  unlink(msa_out[file.exists(msa_out)], force = TRUE)
  unlink(list.files(paste(tempdir(),"alt", sep="/"), full.names = TRUE), force = TRUE, recursive = TRUE)
  # unlink(tempdir(), force = TRUE) # do not use this, it causes problems


  ## Prepare and return output
  ## -------------------------
  # if(score_method=="SA"){
  #   score <- score$residue_pair_score
  # }
  if(inherits(sequences, "AAbin")){
    polentaAA(base.msa, score, "guidance2")
  }else{
    polentaDNA(base.msa, score, "guidance2")
  }
}
